[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "assignment1.html",
    "href": "assignment1.html",
    "title": "Assignment1",
    "section": "",
    "text": "For example, in the above Bored Ape, it has the characteristics of: Yellow Background, White Fur, Orange Beanie. Pretty much everything in the picture is pre-specified and generated through an algorithm that puts it all together.\nA more interesting example is the winner of the 2022 Colorado State Fair Art Competition, Jason Allen, and his piece, “Théâtre D’opéra Spatial”. His piece was actually largely created by a text-to-picture AI called Midjourney, which is similar to DALL-E 2. This program works by giving the AI a prompt, and it generates a picture in about a minute. The pictures are not perfect, but Allen was able to remove the visual artifacts from the picture to create the winning piece. \nAnother Example of generative art comes from https://fronkonstin.com where one can generate some plant art that the color of change be changed. In my case, i changed the color of the plant to ‘darkorchid4’ which is a purple shade.\n\n\n\nPlant\n\n\nFinally, here is a graph that was created that is quite funny.\n\n\n\nFox News Pie\n\n\nThis graph wanted to show the percentage of voters that supported certain presidential candidates during the 2012 election. However, the figure choice is just abysmal. Giving Fox news the benefit of the doubt, we might say that the survey only asked if they supported the GOP candidates, not which one they supported over the other, thus allowing the total percentage to not be capped at 100%. That said, this would be better represented as a bar graph, that way you can display the tight race more accurately, as well as get a quick view as the most likely candidate. Putting the data into a pie chart confuses the general audience as it does not convey meaningful comparison between the candidates, as well as pie charts are generally capped at 100%. Therefore the data could be better represented as a bar graph instead of a pie chart."
  },
  {
    "objectID": "assignment2.html",
    "href": "assignment2.html",
    "title": "assignment 2",
    "section": "",
    "text": "EPPS6356\n\n\n\n\n\n\n\n\n\n\n\nSep 20, 2022\n\n\nNicholas Champagne\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "assignment4.html",
    "href": "assignment4.html",
    "title": "Assignment4: Hackathon",
    "section": "",
    "text": "These are the charts that we made: \nThis first graph shows the average Overall High School GPA for students based on their eighth grade Math Letter Score. It is separated based on the gender of the student, and the width of each columns is representative of the percent of the gendered population. Therefore, when we look at the leftmost column, which is boys who got an A in eighth grade math, they averaged 3.14 High school GPA, and they make up 34% of boys. The data for this code comes from the High School Longitudinal Study for 2009-2013, so you will need that in order to reproduce the data, and it can be found here.There is also the package scales necessary for the code, it just displays a number as a percentage, so you can remove the whole text command if you do not want to install it. The code for the following graph is:\nThis graph shows the number of cancer incidences in an age, and tobacco usage cohort. The main visual interest in this graph is the relative height of the red bar. Since the cohorts had a different total study number, the bar graphs are scaled around the control group so that visual inspection can easily be done on the rate for each bar graph. For example, the oldest age cohort with the highest tobacco usage, found in the bottom right, has a very high rate of cancer incidence as the red bar is very close to the blue bar. This uses the esoph dataset from r, so the data should come with it. The code for this plot is:"
  },
  {
    "objectID": "assignment4.html#coordinator-info",
    "href": "assignment4.html#coordinator-info",
    "title": "Assignment4: Hackathon",
    "section": "Coordinator Info:  ",
    "text": "Coordinator Info:  \nThe following parts of the graphs were done by the team members: Data Collection and Curation - Alden   Graph Formatting - Nick   R code Production - Jim and Will"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Nicholas Champagne",
    "section": "",
    "text": "Hello! My name is Nicholas Champagne. I am currently studying for my Master of Science in Economics, as well as a certification in Economic and Demographic Data Analytics. I also enjoy mathematics."
  },
  {
    "objectID": "posts/Post 1/Blog Post.html",
    "href": "posts/Post 1/Blog Post.html",
    "title": "Assignment 2",
    "section": "",
    "text": "Here is the resulting graph: \nThe next line of code, using the text() command, which adds in text into an existing plot. In this case, we are just adding a description of the graph. \nThe next line of code, using the par() command just separates the graphical environment into subsections. For this case, we are using the option mfrow = c(3,2), which creates 3 rows and 2 columns of subspace for the graphs, or 6 total sub-graph environments.\nAfter defining out some variables we use the par() command again to define some more parameters for our subgraph environment. The las option changes the orientation of the axis label, in our case, 1 moves it to be horizontal to the axis. The mar option changes the margins for the plot. Finally the cex option re-scales the things being plotted, our case decreases the size by 30%. Finally to create a new plot in our sub-graph environment, we use the plot.new() command.\nAfter we create the new plot environment, we can define out the ranges of the plot using the plot.window() command which we feed a x and y range to set at the axis for our plot. After this, we finally create our graph using the line() command, which just draws a line between points, in this case we do it with x and y1 and y2, which we defined earlier. Then we use the points() command to actually plot the points onto the graph, using the pch option to change the type of point, and the bg option to change the color of the points. After we have the main information of the plot, we need to add the rest of the information so it can actually be interpreted. The axis() command creates an axis for a plot, and it requires a side number, the first number in the command, which specifies the side that the axis will be applied to. Finally the at option puts the tic marks on the axis, which uses the seq() command to do it from the first number, to the second number, at the interval of the third number. The box() command adds a box to the graph, and the option bty specifies a box with the top open. Finally we can use the mtext() and text() commands from earlier to add in text to the plot, and in total it looks like this: \nFrom here we are going to create a graph right next to our previously created graph. After defining out some variable parameters, we can use the hist() command to create a histogram of y. The first option is our data, the breaks option is what determines which data points go into which categories, in this case it will be from -3.5, our lowest value, to 3.5, our highest value, with each break spanning 1 unit. The ylim option sets the range for y axis. Finally the feq option, when set to FALSE, displays the data as a percentage of total data, whereas when set to TRUE, it displays the counts of the data points. After this we use the lines() command to draw a normal distribution over our histogram. This is what our histogram looks like: \nThe next graph is a bar plot, which we can use the barplot() command to draw. We use the VADeaths data set, which is the death rates per 1000 in Virginia in 1940. We can change the color of the bar plots for the different age groups by using the col option combined with the gray() command and the seq() to sequentially vary the gray. Adding in the text using the mtext and text command we can add in the numbers for the sizes of each subsection of the bar, and display which data that each bar represents. This is what the updated graph looks like: \nThe next plot that we will create is the box plot, using the boxplot() command, which shows the median, interquartile range, min/maxes, and outliers. For this we will use the Toothgrowth data set. For the box plot itself we have to define a regression, and in this case, we define our regression as length ~ dose. We also use the subset option to add the Ascorbic Acid and Orange Juice regressions separately so that we can change the color of the boxes so that they stand out from each other. The legend() command allows us to define a legend in the plot space and the fill option gives up the ability to specify the colors for our legend. \nThe next plot is a perspective plot, which is used to plot 3 dimensional graphs. After defining out our x,y,z, we can use the persp() command to plot it. The theta and phi options are used to rotate the graph into different viewing angles, in this case we chose 30 degrees for both of them. \nFinally, the last plot to add into our series is the pie chart, which we can use the pie() command to draw it. Since the pie graph isn’t done in a plot environment, we need to edit our par() command with the xpd = FALSE option so that we can add a figure into the plot sub-environment. The pie command takes our data set defined in the line above, and creates slices of the data representative of the percentage of the total. We also can define the colors of each slice by using the col option. \nNote that each of these graphs were put into the sub-environments that we defined earlier when we used the first par() command with the mfrow option. If we wanted any of these graph on its own, we can just run the code for the graph, but we have to make sure that the code is not trying to push it into a sub environment. If the graphs are no longer necessary, we can use the dev.off() command to remove all the existing graphs."
  },
  {
    "objectID": "assignment5.html",
    "href": "assignment5.html",
    "title": "Assignment 5: More Graphs",
    "section": "",
    "text": "For this assignment, I used the same data set but tried to represent different uses of the graphs to understand the strengths of them. The data comes from my favorite game, Fire Emblem Awakening, and it is the maximum stats of each class. The goal is to get an understanding of the strengths of each class as well as understand of why certain classes are better than others. The table form of the data can be found here, in the promoted class section (There are 2 special classes that are included in the table as they are playable in the base game). For this, we are only interested in the stats that vary (STR,MAG,SKL,SPD,DEF,RES), as the other two (HP,LCK) do not change between classes. Here is a description of the stats that we are looking at:\n\nStr - Strength, increases physical damage\nMag - Magic, increases magic damage\nSkl - Skill, affects hit rate\nSpd - Speed, affects dodge rate, and if 5 more than opponent you get to hit twice\nDef - Defense, reduces physical damage\nRes - Resistance, reduces magic damage"
  },
  {
    "objectID": "assignment5.html#average-stats",
    "href": "assignment5.html#average-stats",
    "title": "Assignment 5: More Graphs",
    "section": "Average Stats",
    "text": "Average Stats\nThe first thing we want to look at is the average stats of all the classes combined. This gives us some insight into how we might expect a specific class to interact with the average case scenario."
  },
  {
    "objectID": "assignment5.html#total-stats",
    "href": "assignment5.html#total-stats",
    "title": "Assignment 5: More Graphs",
    "section": "Total Stats",
    "text": "Total Stats\nThe first thing that we can look at is the sum of each stat to see how different rank. More stats is good, therefore we might have an expectation that classes with lots of stats are generally the best. Furthermore, units will generally specialize in dealing a specific type of damage depending of the weapons that class can wield. Units that are classified as Physical can only wield swords, axes, lances, bows, or stones. Units classified as Magic can only wield Staffs or Tomes. Hybrid Classes can wield a mix of either. It is worth noting that Physical units can still deal magic damage through special weapons (and thereby have a use for their magic stat), but Magic units can not deal physical damage at all.\n\nFrom this table We might expect that the General class is the best class in the game, while the Taguel is the worst class in the game. But there are some more complexities that we need to think about, specifically how each stat is distributed in the class."
  },
  {
    "objectID": "assignment5.html#stat-distribution",
    "href": "assignment5.html#stat-distribution",
    "title": "Assignment 5: More Graphs",
    "section": "Stat Distribution",
    "text": "Stat Distribution\nBelow is a radar plot of each stat for all of the classes:\n\nThis is a lot to look at so lets take a look at a couple of specific classes, and overlay each one with the average stats to better understand what we are looking at. As an example, we will first look at the General class as that one was the highest up on the stat total.\n\nGeneral\n\nAt first this may seem good, however it has a major weakness in its speed and resistance, meaning that it will likely die after 1 battle against people that deal magic damage while not being able to utilize its massive strength stat. Another good example would be to look at a class that scored pretty low on the ranking, like the Trickster.\n\n\nTrickster\n\nThis class does not dwarf the average scenario like the general does, but it trades it off with some flexibility. The class has an above average speed stat, as well as being a hybrid class which allows the unit to better counter classes with specific damage weaknesses, like the General. The unit is fairly weak defensively, but that is manageable because it is not likely to be doubled in a turn like the General is. Overall, while not the best class in the game, it is a solid class with options, unlike the paladin which is just generally great.\n\n\nPaladin\n\nThe Paladin does not have any clear weaknesses, while also being stronger and tankier. This allows any paladin to be flexible and easily specialize into any kind of role, without having any clear path to beat them easily. Overall, the Paladin is one of the best classes in the game, as it has a strong stat distribution as well as plenty of stats to work with."
  },
  {
    "objectID": "assignment7.html",
    "href": "assignment7.html",
    "title": "Assignment 7: Shiny Hackathon",
    "section": "",
    "text": "Code link"
  },
  {
    "objectID": "assignment7.html#synergy-report",
    "href": "assignment7.html#synergy-report",
    "title": "Assignment 7: Shiny Hackathon",
    "section": "Synergy Report",
    "text": "Synergy Report\nHere is the group Synergy Report:\n\nAlden - Time series graph\nWill - Pokemon Stats graph\nNick - Animal Crossing graph\nJim - Animal Crossing graph"
  },
  {
    "objectID": "assignment9.html",
    "href": "assignment9.html",
    "title": "Assignment 9: Time Seies",
    "section": "",
    "text": "NOTE: NOT A TIME SERIES EXPERT! I MAY BE WRONG ABOUT DESCRIPTION OF DATA"
  },
  {
    "objectID": "assignment9.html#traffic-deaths",
    "href": "assignment9.html#traffic-deaths",
    "title": "Assignment 9: Time Seies",
    "section": "Traffic Deaths",
    "text": "Traffic Deaths\nFinally, the last type of data to look at is data with the pdq format, which deals with auto regressive data, data that trends with previous values of itself, and moving average data, which deals with average values of data wrapped around itself, and d deals with the amount of differentiation needed.\n\ncars <- read.csv(file = \"Cars.csv\")\n#Just some data manipulation to pass on data to dygraph\ncars$Year <- yearmon(cars$Year)\nk <- 3\n#This creates the moving average through the rollmean function\ncars$roll <- c(rep(NA,k-1),rollmean(cars$Total, k = k))\ncars1 <- xts(cars[,2:3], order.by = cars$Year)\ncolnames(cars1) <- c(\"Crash Fatalities\",\"Moving Average\")\n\n#Simple example of a Moving Average Graph in this case\n#p = 0, d = 0, and q = k which is 3 from the rollmean funciton\ndygraph(cars1) %>%\n  dyRangeSelector() %>%\n  dyCSS(\"dygraph.css\")\n\n\n\n\n\nThis data is just a moving average data set, so p and d are equal to 0, while q is equal to 2 in this situation."
  },
  {
    "objectID": "assignment9.html#gdp-analysis",
    "href": "assignment9.html#gdp-analysis",
    "title": "Assignment 9: Time Seies",
    "section": "GDP Analysis",
    "text": "GDP Analysis\n\nReal GDP\nThis first graph looks at the Real GDP over time from 1947 to July 2022. This is a classic economic example of a trending time series as Real GDP tends to increase over time exponentially. Here is what the data looks like:\n\nrgdp <- read.csv(\"GDP.csv\")\n\nrgdp$DATE <- as.yearmon(rgdp$DATE)\nrgdp.xts <- xts(rgdp$GDP, order.by = rgdp$DATE)\n\nts_plot(rgdp.xts,\n        title = \"Real GDP\",\n        Ytitle = \"Billions of Dollars\")\n\n\n\n\n\nSince we know that Real GDP is trending exponentially, we can de-trend it by taking the log of it, which looks like this:\n\n#Looks, its de-trended (mostly)\nts_plot(log(rgdp.xts),\n        title = \"Real GDP\",\n        Ytitle = \"log of Billions of Dollars\")\n\n\n\n\n\n\n\nPercent Change in Real GDP\nAnother way we can de-trend Real GDP is by looking at the percent change in Real GDP, which looks like this:\n\nrgdpc <- read.csv(\"GDPC1.csv\")\nrgdpc$DATE <- as.yearmon(rgdpc$DATE)\nrgdpc.xts <- xts(rgdpc$GDP, order.by = rgdpc$DATE)\nts_plot(rgdpc.xts,\n        title = \"Percent Change in Real GDP\",\n        Ytitle = \"Percent Change\")\n\n\n\n\n\nThis data has now become stationary data as we have de-trended it, and we can do other time series analysis on it."
  },
  {
    "objectID": "assignment10.html",
    "href": "assignment10.html",
    "title": "Assignment 10: Breakpoint Models",
    "section": "",
    "text": "The first graph shown is just the trending industrial production index collected by FRED. This graph is a great visualization as it has all the necessary components without looking messy.\n\n\n\nThe next couple graphs deal with breakpoint models, where now we want to choose the model that has the least amount of breakpoints in it, as the lower our Bayesian Information Criteria (BIC) is, generally speaking, the better the model is.\n\nThis first graph uses data of the production index from 1947 to current time, and it suggests that there are no breakpoints in the graph. This graph is an excellent diagnostic and visualization tool, but the only thing that I would change would be to slightly alter the title of the graph so that it is easier to tell which model this is. But, it seems there are command limitations from this, so external methods are likely needed.\n\nThis next graph uses data from 1947 to 2016, at it suggests that there should be 4 breakpoints in the model. This graph is similar to the previous one visually speaking, only external methods to identify this graph as opposed to the other one would be nice, but there are some command limitations.\n This graph shows there those predicted breakpoints are. The black line is the raw data, the green line is the predicted different in index, and the vertical dotted lines are the breakpoints, with a confidence region in blue at the very bottom. For this graph, a legend is necessary as there are quite a few different things going on within the graph, so some help understand which is what would be very helpful."
  },
  {
    "objectID": "assignment10.html#seatbelts",
    "href": "assignment10.html#seatbelts",
    "title": "Assignment 10: Breakpoint Models",
    "section": "Seatbelts",
    "text": "Seatbelts\n\nThis graph shows several things. First, the log10 of the data before car manufactures were required to install seatbelts into cars of car deaths. The second and third graphs show the importance of different lag variables to create a time series model. The only change I would make to this model is just changing the y axis label of the first graph to log10(Deaths) and putting a title in just to clarify the graph.\n\nThis graph shows the prediction of the next 2 years of data in red with the confidence region shown in blue against the actual next 2 years of data, shown in black. The only change I would add to this graph is maybe a legend in the bottom left, but The graph is likely straightforward enough as is."
  },
  {
    "objectID": "assignment10.html#rw-intervention",
    "href": "assignment10.html#rw-intervention",
    "title": "Assignment 10: Breakpoint Models",
    "section": "RW Intervention",
    "text": "RW Intervention\nFor this example, fit.inf.L0 bombed R, and I really couldn’t figure out why it was doing that, as a result I was unable to properly replicate some plots.\n\nChangepoint estimation\nThis first 2 graphs show how change point estimation works using lambda criteria and different estimation methods.\n\nThis first method shows the estimated change points using Binary Segmentation, and a total breakpoints of 10. The red lines shows the estimated breakpoints in the model, while the black the data. I think that this model is difficult to understand, but i believe that the interpretation of this is were breakpoints likely are, which in this case may be 4-5 locations, which is were the red lines are grouped together. As a result, if I were showing the graph, varying the color of different grouped lines may help people understand that some of the estimations are near each other for a reason.\n\nThis second graph shows the estimated change points using L0 segmentation and a lambda of 4. This graph is a hot mess, likely because lambda may need to be bigger, but I don’t fully understand this method anyways.\n\n\nCost Function\n\nI think this data shows at which change points the cost of choosing mu is minimized, and we want to minimize that. In this case, the cost of mu is minimized at around 3, with the changepoint at 200, which is what is expected as the data was set up in that way. I do not really understand this graph, so I cannot tell you what is shown or why, and how it can be improved."
  }
]